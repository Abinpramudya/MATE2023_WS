// Generated by gencpp from file master_package/RB2CB.msg
// DO NOT EDIT!


#ifndef MASTER_PACKAGE_MESSAGE_RB2CB_H
#define MASTER_PACKAGE_MESSAGE_RB2CB_H


#include <string>
#include <vector>
#include <memory>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>


namespace master_package
{
template <class ContainerAllocator>
struct RB2CB_
{
  typedef RB2CB_<ContainerAllocator> Type;

  RB2CB_()
    : voltage(0)
    , pressure(0)
    , temperature(0)
    , actual_depth(0)
    , actual_roll(0)
    , actual_pitch(0)
    , actual_yaw(0)
    , isAutonomous(false)
    , kp_roll(0)
    , ki_roll(0)
    , kd_roll(0)
    , target_stp_roll(0)
    , monitor_stp_roll(0)
    , kp_pitch(0)
    , ki_pitch(0)
    , kd_pitch(0)
    , target_stp_pitch(0)
    , monitor_stp_pitch(0)
    , kp_yaw(0)
    , ki_yaw(0)
    , kd_yaw(0)
    , target_stp_yaw(0)
    , monitor_stp_yaw(0)
    , kp_depth(0)
    , ki_depth(0)
    , kd_depth(0)
    , target_stp_depth(0)
    , monitor_stp_depth(0)
    , isRollLocked(false)
    , isYawLocked(false)
    , isPitchLocked(false)
    , isDepthLocked(false)
    , throttle(0)
    , thruster_FR(0)
    , thruster_FL(0)
    , thruster_CR(0)
    , thruster_CL(0)
    , thruster_BR(0)
    , thruster_BL(0)
    , thruster_BC(0)
    , PID_DepthMode()
    , PID_StabilizeMode()
    , Mission1_Mode()
    , Mission2_Mode()
    , Mission3_Status()
    , Mission4_Status()
    , stepper_degree(0)
    , pneumatic_status(false)  {
    }
  RB2CB_(const ContainerAllocator& _alloc)
    : voltage(0)
    , pressure(0)
    , temperature(0)
    , actual_depth(0)
    , actual_roll(0)
    , actual_pitch(0)
    , actual_yaw(0)
    , isAutonomous(false)
    , kp_roll(0)
    , ki_roll(0)
    , kd_roll(0)
    , target_stp_roll(0)
    , monitor_stp_roll(0)
    , kp_pitch(0)
    , ki_pitch(0)
    , kd_pitch(0)
    , target_stp_pitch(0)
    , monitor_stp_pitch(0)
    , kp_yaw(0)
    , ki_yaw(0)
    , kd_yaw(0)
    , target_stp_yaw(0)
    , monitor_stp_yaw(0)
    , kp_depth(0)
    , ki_depth(0)
    , kd_depth(0)
    , target_stp_depth(0)
    , monitor_stp_depth(0)
    , isRollLocked(false)
    , isYawLocked(false)
    , isPitchLocked(false)
    , isDepthLocked(false)
    , throttle(0)
    , thruster_FR(0)
    , thruster_FL(0)
    , thruster_CR(0)
    , thruster_CL(0)
    , thruster_BR(0)
    , thruster_BL(0)
    , thruster_BC(0)
    , PID_DepthMode(_alloc)
    , PID_StabilizeMode(_alloc)
    , Mission1_Mode(_alloc)
    , Mission2_Mode(_alloc)
    , Mission3_Status(_alloc)
    , Mission4_Status(_alloc)
    , stepper_degree(0)
    , pneumatic_status(false)  {
  (void)_alloc;
    }



   typedef int64_t _voltage_type;
  _voltage_type voltage;

   typedef int64_t _pressure_type;
  _pressure_type pressure;

   typedef int64_t _temperature_type;
  _temperature_type temperature;

   typedef int64_t _actual_depth_type;
  _actual_depth_type actual_depth;

   typedef int64_t _actual_roll_type;
  _actual_roll_type actual_roll;

   typedef int64_t _actual_pitch_type;
  _actual_pitch_type actual_pitch;

   typedef int64_t _actual_yaw_type;
  _actual_yaw_type actual_yaw;

   typedef uint8_t _isAutonomous_type;
  _isAutonomous_type isAutonomous;

   typedef int64_t _kp_roll_type;
  _kp_roll_type kp_roll;

   typedef int64_t _ki_roll_type;
  _ki_roll_type ki_roll;

   typedef int64_t _kd_roll_type;
  _kd_roll_type kd_roll;

   typedef int64_t _target_stp_roll_type;
  _target_stp_roll_type target_stp_roll;

   typedef int64_t _monitor_stp_roll_type;
  _monitor_stp_roll_type monitor_stp_roll;

   typedef int64_t _kp_pitch_type;
  _kp_pitch_type kp_pitch;

   typedef int64_t _ki_pitch_type;
  _ki_pitch_type ki_pitch;

   typedef int64_t _kd_pitch_type;
  _kd_pitch_type kd_pitch;

   typedef int64_t _target_stp_pitch_type;
  _target_stp_pitch_type target_stp_pitch;

   typedef int64_t _monitor_stp_pitch_type;
  _monitor_stp_pitch_type monitor_stp_pitch;

   typedef int64_t _kp_yaw_type;
  _kp_yaw_type kp_yaw;

   typedef int64_t _ki_yaw_type;
  _ki_yaw_type ki_yaw;

   typedef int64_t _kd_yaw_type;
  _kd_yaw_type kd_yaw;

   typedef int64_t _target_stp_yaw_type;
  _target_stp_yaw_type target_stp_yaw;

   typedef int64_t _monitor_stp_yaw_type;
  _monitor_stp_yaw_type monitor_stp_yaw;

   typedef int64_t _kp_depth_type;
  _kp_depth_type kp_depth;

   typedef int64_t _ki_depth_type;
  _ki_depth_type ki_depth;

   typedef int64_t _kd_depth_type;
  _kd_depth_type kd_depth;

   typedef int64_t _target_stp_depth_type;
  _target_stp_depth_type target_stp_depth;

   typedef int64_t _monitor_stp_depth_type;
  _monitor_stp_depth_type monitor_stp_depth;

   typedef uint8_t _isRollLocked_type;
  _isRollLocked_type isRollLocked;

   typedef uint8_t _isYawLocked_type;
  _isYawLocked_type isYawLocked;

   typedef uint8_t _isPitchLocked_type;
  _isPitchLocked_type isPitchLocked;

   typedef uint8_t _isDepthLocked_type;
  _isDepthLocked_type isDepthLocked;

   typedef int64_t _throttle_type;
  _throttle_type throttle;

   typedef int64_t _thruster_FR_type;
  _thruster_FR_type thruster_FR;

   typedef int64_t _thruster_FL_type;
  _thruster_FL_type thruster_FL;

   typedef int64_t _thruster_CR_type;
  _thruster_CR_type thruster_CR;

   typedef int64_t _thruster_CL_type;
  _thruster_CL_type thruster_CL;

   typedef int64_t _thruster_BR_type;
  _thruster_BR_type thruster_BR;

   typedef int64_t _thruster_BL_type;
  _thruster_BL_type thruster_BL;

   typedef int64_t _thruster_BC_type;
  _thruster_BC_type thruster_BC;

   typedef std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>> _PID_DepthMode_type;
  _PID_DepthMode_type PID_DepthMode;

   typedef std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>> _PID_StabilizeMode_type;
  _PID_StabilizeMode_type PID_StabilizeMode;

   typedef std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>> _Mission1_Mode_type;
  _Mission1_Mode_type Mission1_Mode;

   typedef std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>> _Mission2_Mode_type;
  _Mission2_Mode_type Mission2_Mode;

   typedef std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>> _Mission3_Status_type;
  _Mission3_Status_type Mission3_Status;

   typedef std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>> _Mission4_Status_type;
  _Mission4_Status_type Mission4_Status;

   typedef int64_t _stepper_degree_type;
  _stepper_degree_type stepper_degree;

   typedef uint8_t _pneumatic_status_type;
  _pneumatic_status_type pneumatic_status;





  typedef boost::shared_ptr< ::master_package::RB2CB_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::master_package::RB2CB_<ContainerAllocator> const> ConstPtr;

}; // struct RB2CB_

typedef ::master_package::RB2CB_<std::allocator<void> > RB2CB;

typedef boost::shared_ptr< ::master_package::RB2CB > RB2CBPtr;
typedef boost::shared_ptr< ::master_package::RB2CB const> RB2CBConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::master_package::RB2CB_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::master_package::RB2CB_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::master_package::RB2CB_<ContainerAllocator1> & lhs, const ::master_package::RB2CB_<ContainerAllocator2> & rhs)
{
  return lhs.voltage == rhs.voltage &&
    lhs.pressure == rhs.pressure &&
    lhs.temperature == rhs.temperature &&
    lhs.actual_depth == rhs.actual_depth &&
    lhs.actual_roll == rhs.actual_roll &&
    lhs.actual_pitch == rhs.actual_pitch &&
    lhs.actual_yaw == rhs.actual_yaw &&
    lhs.isAutonomous == rhs.isAutonomous &&
    lhs.kp_roll == rhs.kp_roll &&
    lhs.ki_roll == rhs.ki_roll &&
    lhs.kd_roll == rhs.kd_roll &&
    lhs.target_stp_roll == rhs.target_stp_roll &&
    lhs.monitor_stp_roll == rhs.monitor_stp_roll &&
    lhs.kp_pitch == rhs.kp_pitch &&
    lhs.ki_pitch == rhs.ki_pitch &&
    lhs.kd_pitch == rhs.kd_pitch &&
    lhs.target_stp_pitch == rhs.target_stp_pitch &&
    lhs.monitor_stp_pitch == rhs.monitor_stp_pitch &&
    lhs.kp_yaw == rhs.kp_yaw &&
    lhs.ki_yaw == rhs.ki_yaw &&
    lhs.kd_yaw == rhs.kd_yaw &&
    lhs.target_stp_yaw == rhs.target_stp_yaw &&
    lhs.monitor_stp_yaw == rhs.monitor_stp_yaw &&
    lhs.kp_depth == rhs.kp_depth &&
    lhs.ki_depth == rhs.ki_depth &&
    lhs.kd_depth == rhs.kd_depth &&
    lhs.target_stp_depth == rhs.target_stp_depth &&
    lhs.monitor_stp_depth == rhs.monitor_stp_depth &&
    lhs.isRollLocked == rhs.isRollLocked &&
    lhs.isYawLocked == rhs.isYawLocked &&
    lhs.isPitchLocked == rhs.isPitchLocked &&
    lhs.isDepthLocked == rhs.isDepthLocked &&
    lhs.throttle == rhs.throttle &&
    lhs.thruster_FR == rhs.thruster_FR &&
    lhs.thruster_FL == rhs.thruster_FL &&
    lhs.thruster_CR == rhs.thruster_CR &&
    lhs.thruster_CL == rhs.thruster_CL &&
    lhs.thruster_BR == rhs.thruster_BR &&
    lhs.thruster_BL == rhs.thruster_BL &&
    lhs.thruster_BC == rhs.thruster_BC &&
    lhs.PID_DepthMode == rhs.PID_DepthMode &&
    lhs.PID_StabilizeMode == rhs.PID_StabilizeMode &&
    lhs.Mission1_Mode == rhs.Mission1_Mode &&
    lhs.Mission2_Mode == rhs.Mission2_Mode &&
    lhs.Mission3_Status == rhs.Mission3_Status &&
    lhs.Mission4_Status == rhs.Mission4_Status &&
    lhs.stepper_degree == rhs.stepper_degree &&
    lhs.pneumatic_status == rhs.pneumatic_status;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::master_package::RB2CB_<ContainerAllocator1> & lhs, const ::master_package::RB2CB_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace master_package

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsMessage< ::master_package::RB2CB_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::master_package::RB2CB_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::master_package::RB2CB_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::master_package::RB2CB_<ContainerAllocator> const>
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::master_package::RB2CB_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::master_package::RB2CB_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::master_package::RB2CB_<ContainerAllocator> >
{
  static const char* value()
  {
    return "40f3113b257b1d34d4bcd7bdbef4a34d";
  }

  static const char* value(const ::master_package::RB2CB_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x40f3113b257b1d34ULL;
  static const uint64_t static_value2 = 0xd4bcd7bdbef4a34dULL;
};

template<class ContainerAllocator>
struct DataType< ::master_package::RB2CB_<ContainerAllocator> >
{
  static const char* value()
  {
    return "master_package/RB2CB";
  }

  static const char* value(const ::master_package::RB2CB_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::master_package::RB2CB_<ContainerAllocator> >
{
  static const char* value()
  {
    return "# Overall Robot Status\n"
"int64 voltage\n"
"int64 pressure\n"
"int64 temperature\n"
"int64 actual_depth\n"
"int64 actual_roll  \n"
"int64 actual_pitch\n"
"int64 actual_yaw\n"
"bool isAutonomous\n"
"\n"
"# PID \n"
"int64 kp_roll\n"
"int64 ki_roll\n"
"int64 kd_roll\n"
"int64 target_stp_roll\n"
"int64 monitor_stp_roll\n"
"int64 kp_pitch\n"
"int64 ki_pitch\n"
"int64 kd_pitch\n"
"int64 target_stp_pitch\n"
"int64 monitor_stp_pitch\n"
"int64 kp_yaw\n"
"int64 ki_yaw\n"
"int64 kd_yaw\n"
"int64 target_stp_yaw\n"
"int64 monitor_stp_yaw\n"
"int64 kp_depth\n"
"int64 ki_depth\n"
"int64 kd_depth\n"
"int64 target_stp_depth\n"
"int64 monitor_stp_depth\n"
"\n"
"# Lock Status\n"
"bool isRollLocked\n"
"bool isYawLocked\n"
"bool isPitchLocked \n"
"bool isDepthLocked\n"
"\n"
"# Thrusters\n"
"int64 throttle\n"
"int64 thruster_FR\n"
"int64 thruster_FL\n"
"int64 thruster_CR\n"
"int64 thruster_CL\n"
"int64 thruster_BR\n"
"int64 thruster_BL\n"
"int64 thruster_BC\n"
"\n"
"# PID Mode\n"
"string PID_DepthMode\n"
"string PID_StabilizeMode\n"
"\n"
"# Mission Reserved Button\n"
"# Circle Button\n"
"string Mission1_Mode\n"
"# Cross Button\n"
"string Mission2_Mode\n"
"# Start Button\n"
"string Mission3_Status\n"
"# Select Button\n"
"string Mission4_Status\n"
"\n"
"# Gripper\n"
"int64 stepper_degree\n"
"bool pneumatic_status\n"
;
  }

  static const char* value(const ::master_package::RB2CB_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::master_package::RB2CB_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.voltage);
      stream.next(m.pressure);
      stream.next(m.temperature);
      stream.next(m.actual_depth);
      stream.next(m.actual_roll);
      stream.next(m.actual_pitch);
      stream.next(m.actual_yaw);
      stream.next(m.isAutonomous);
      stream.next(m.kp_roll);
      stream.next(m.ki_roll);
      stream.next(m.kd_roll);
      stream.next(m.target_stp_roll);
      stream.next(m.monitor_stp_roll);
      stream.next(m.kp_pitch);
      stream.next(m.ki_pitch);
      stream.next(m.kd_pitch);
      stream.next(m.target_stp_pitch);
      stream.next(m.monitor_stp_pitch);
      stream.next(m.kp_yaw);
      stream.next(m.ki_yaw);
      stream.next(m.kd_yaw);
      stream.next(m.target_stp_yaw);
      stream.next(m.monitor_stp_yaw);
      stream.next(m.kp_depth);
      stream.next(m.ki_depth);
      stream.next(m.kd_depth);
      stream.next(m.target_stp_depth);
      stream.next(m.monitor_stp_depth);
      stream.next(m.isRollLocked);
      stream.next(m.isYawLocked);
      stream.next(m.isPitchLocked);
      stream.next(m.isDepthLocked);
      stream.next(m.throttle);
      stream.next(m.thruster_FR);
      stream.next(m.thruster_FL);
      stream.next(m.thruster_CR);
      stream.next(m.thruster_CL);
      stream.next(m.thruster_BR);
      stream.next(m.thruster_BL);
      stream.next(m.thruster_BC);
      stream.next(m.PID_DepthMode);
      stream.next(m.PID_StabilizeMode);
      stream.next(m.Mission1_Mode);
      stream.next(m.Mission2_Mode);
      stream.next(m.Mission3_Status);
      stream.next(m.Mission4_Status);
      stream.next(m.stepper_degree);
      stream.next(m.pneumatic_status);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct RB2CB_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::master_package::RB2CB_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::master_package::RB2CB_<ContainerAllocator>& v)
  {
    s << indent << "voltage: ";
    Printer<int64_t>::stream(s, indent + "  ", v.voltage);
    s << indent << "pressure: ";
    Printer<int64_t>::stream(s, indent + "  ", v.pressure);
    s << indent << "temperature: ";
    Printer<int64_t>::stream(s, indent + "  ", v.temperature);
    s << indent << "actual_depth: ";
    Printer<int64_t>::stream(s, indent + "  ", v.actual_depth);
    s << indent << "actual_roll: ";
    Printer<int64_t>::stream(s, indent + "  ", v.actual_roll);
    s << indent << "actual_pitch: ";
    Printer<int64_t>::stream(s, indent + "  ", v.actual_pitch);
    s << indent << "actual_yaw: ";
    Printer<int64_t>::stream(s, indent + "  ", v.actual_yaw);
    s << indent << "isAutonomous: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.isAutonomous);
    s << indent << "kp_roll: ";
    Printer<int64_t>::stream(s, indent + "  ", v.kp_roll);
    s << indent << "ki_roll: ";
    Printer<int64_t>::stream(s, indent + "  ", v.ki_roll);
    s << indent << "kd_roll: ";
    Printer<int64_t>::stream(s, indent + "  ", v.kd_roll);
    s << indent << "target_stp_roll: ";
    Printer<int64_t>::stream(s, indent + "  ", v.target_stp_roll);
    s << indent << "monitor_stp_roll: ";
    Printer<int64_t>::stream(s, indent + "  ", v.monitor_stp_roll);
    s << indent << "kp_pitch: ";
    Printer<int64_t>::stream(s, indent + "  ", v.kp_pitch);
    s << indent << "ki_pitch: ";
    Printer<int64_t>::stream(s, indent + "  ", v.ki_pitch);
    s << indent << "kd_pitch: ";
    Printer<int64_t>::stream(s, indent + "  ", v.kd_pitch);
    s << indent << "target_stp_pitch: ";
    Printer<int64_t>::stream(s, indent + "  ", v.target_stp_pitch);
    s << indent << "monitor_stp_pitch: ";
    Printer<int64_t>::stream(s, indent + "  ", v.monitor_stp_pitch);
    s << indent << "kp_yaw: ";
    Printer<int64_t>::stream(s, indent + "  ", v.kp_yaw);
    s << indent << "ki_yaw: ";
    Printer<int64_t>::stream(s, indent + "  ", v.ki_yaw);
    s << indent << "kd_yaw: ";
    Printer<int64_t>::stream(s, indent + "  ", v.kd_yaw);
    s << indent << "target_stp_yaw: ";
    Printer<int64_t>::stream(s, indent + "  ", v.target_stp_yaw);
    s << indent << "monitor_stp_yaw: ";
    Printer<int64_t>::stream(s, indent + "  ", v.monitor_stp_yaw);
    s << indent << "kp_depth: ";
    Printer<int64_t>::stream(s, indent + "  ", v.kp_depth);
    s << indent << "ki_depth: ";
    Printer<int64_t>::stream(s, indent + "  ", v.ki_depth);
    s << indent << "kd_depth: ";
    Printer<int64_t>::stream(s, indent + "  ", v.kd_depth);
    s << indent << "target_stp_depth: ";
    Printer<int64_t>::stream(s, indent + "  ", v.target_stp_depth);
    s << indent << "monitor_stp_depth: ";
    Printer<int64_t>::stream(s, indent + "  ", v.monitor_stp_depth);
    s << indent << "isRollLocked: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.isRollLocked);
    s << indent << "isYawLocked: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.isYawLocked);
    s << indent << "isPitchLocked: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.isPitchLocked);
    s << indent << "isDepthLocked: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.isDepthLocked);
    s << indent << "throttle: ";
    Printer<int64_t>::stream(s, indent + "  ", v.throttle);
    s << indent << "thruster_FR: ";
    Printer<int64_t>::stream(s, indent + "  ", v.thruster_FR);
    s << indent << "thruster_FL: ";
    Printer<int64_t>::stream(s, indent + "  ", v.thruster_FL);
    s << indent << "thruster_CR: ";
    Printer<int64_t>::stream(s, indent + "  ", v.thruster_CR);
    s << indent << "thruster_CL: ";
    Printer<int64_t>::stream(s, indent + "  ", v.thruster_CL);
    s << indent << "thruster_BR: ";
    Printer<int64_t>::stream(s, indent + "  ", v.thruster_BR);
    s << indent << "thruster_BL: ";
    Printer<int64_t>::stream(s, indent + "  ", v.thruster_BL);
    s << indent << "thruster_BC: ";
    Printer<int64_t>::stream(s, indent + "  ", v.thruster_BC);
    s << indent << "PID_DepthMode: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>>>::stream(s, indent + "  ", v.PID_DepthMode);
    s << indent << "PID_StabilizeMode: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>>>::stream(s, indent + "  ", v.PID_StabilizeMode);
    s << indent << "Mission1_Mode: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>>>::stream(s, indent + "  ", v.Mission1_Mode);
    s << indent << "Mission2_Mode: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>>>::stream(s, indent + "  ", v.Mission2_Mode);
    s << indent << "Mission3_Status: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>>>::stream(s, indent + "  ", v.Mission3_Status);
    s << indent << "Mission4_Status: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>>>::stream(s, indent + "  ", v.Mission4_Status);
    s << indent << "stepper_degree: ";
    Printer<int64_t>::stream(s, indent + "  ", v.stepper_degree);
    s << indent << "pneumatic_status: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.pneumatic_status);
  }
};

} // namespace message_operations
} // namespace ros

#endif // MASTER_PACKAGE_MESSAGE_RB2CB_H
