// Generated by gencpp from file toggle_pkg/finalJoy.msg
// DO NOT EDIT!


#ifndef TOGGLE_PKG_MESSAGE_FINALJOY_H
#define TOGGLE_PKG_MESSAGE_FINALJOY_H


#include <string>
#include <vector>
#include <memory>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>


namespace toggle_pkg
{
template <class ContainerAllocator>
struct finalJoy_
{
  typedef finalJoy_<ContainerAllocator> Type;

  finalJoy_()
    : leftX()
    , leftY()
    , rightX()
    , rightY()
    , alter_right_x()
    , alter_right_y()
    , R1()
    , R2()
    , L1()
    , L2()
    , btn_triangle()
    , btn_square()
    , btn_circle()
    , btn_cross()
    , AutonomMode()
    , PID_DepthMode()
    , PID_StabilizeMode()
    , throttle()
    , Mission1_Mode()
    , Mission2_Mode()
    , Mission3_Status()
    , Mission4_Status()  {
    }
  finalJoy_(const ContainerAllocator& _alloc)
    : leftX(_alloc)
    , leftY(_alloc)
    , rightX(_alloc)
    , rightY(_alloc)
    , alter_right_x(_alloc)
    , alter_right_y(_alloc)
    , R1(_alloc)
    , R2(_alloc)
    , L1(_alloc)
    , L2(_alloc)
    , btn_triangle(_alloc)
    , btn_square(_alloc)
    , btn_circle(_alloc)
    , btn_cross(_alloc)
    , AutonomMode(_alloc)
    , PID_DepthMode(_alloc)
    , PID_StabilizeMode(_alloc)
    , throttle(_alloc)
    , Mission1_Mode(_alloc)
    , Mission2_Mode(_alloc)
    , Mission3_Status(_alloc)
    , Mission4_Status(_alloc)  {
  (void)_alloc;
    }



   typedef std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>> _leftX_type;
  _leftX_type leftX;

   typedef std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>> _leftY_type;
  _leftY_type leftY;

   typedef std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>> _rightX_type;
  _rightX_type rightX;

   typedef std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>> _rightY_type;
  _rightY_type rightY;

   typedef std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>> _alter_right_x_type;
  _alter_right_x_type alter_right_x;

   typedef std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>> _alter_right_y_type;
  _alter_right_y_type alter_right_y;

   typedef std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>> _R1_type;
  _R1_type R1;

   typedef std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>> _R2_type;
  _R2_type R2;

   typedef std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>> _L1_type;
  _L1_type L1;

   typedef std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>> _L2_type;
  _L2_type L2;

   typedef std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>> _btn_triangle_type;
  _btn_triangle_type btn_triangle;

   typedef std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>> _btn_square_type;
  _btn_square_type btn_square;

   typedef std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>> _btn_circle_type;
  _btn_circle_type btn_circle;

   typedef std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>> _btn_cross_type;
  _btn_cross_type btn_cross;

   typedef std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>> _AutonomMode_type;
  _AutonomMode_type AutonomMode;

   typedef std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>> _PID_DepthMode_type;
  _PID_DepthMode_type PID_DepthMode;

   typedef std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>> _PID_StabilizeMode_type;
  _PID_StabilizeMode_type PID_StabilizeMode;

   typedef std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>> _throttle_type;
  _throttle_type throttle;

   typedef std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>> _Mission1_Mode_type;
  _Mission1_Mode_type Mission1_Mode;

   typedef std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>> _Mission2_Mode_type;
  _Mission2_Mode_type Mission2_Mode;

   typedef std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>> _Mission3_Status_type;
  _Mission3_Status_type Mission3_Status;

   typedef std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>> _Mission4_Status_type;
  _Mission4_Status_type Mission4_Status;





  typedef boost::shared_ptr< ::toggle_pkg::finalJoy_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::toggle_pkg::finalJoy_<ContainerAllocator> const> ConstPtr;

}; // struct finalJoy_

typedef ::toggle_pkg::finalJoy_<std::allocator<void> > finalJoy;

typedef boost::shared_ptr< ::toggle_pkg::finalJoy > finalJoyPtr;
typedef boost::shared_ptr< ::toggle_pkg::finalJoy const> finalJoyConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::toggle_pkg::finalJoy_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::toggle_pkg::finalJoy_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::toggle_pkg::finalJoy_<ContainerAllocator1> & lhs, const ::toggle_pkg::finalJoy_<ContainerAllocator2> & rhs)
{
  return lhs.leftX == rhs.leftX &&
    lhs.leftY == rhs.leftY &&
    lhs.rightX == rhs.rightX &&
    lhs.rightY == rhs.rightY &&
    lhs.alter_right_x == rhs.alter_right_x &&
    lhs.alter_right_y == rhs.alter_right_y &&
    lhs.R1 == rhs.R1 &&
    lhs.R2 == rhs.R2 &&
    lhs.L1 == rhs.L1 &&
    lhs.L2 == rhs.L2 &&
    lhs.btn_triangle == rhs.btn_triangle &&
    lhs.btn_square == rhs.btn_square &&
    lhs.btn_circle == rhs.btn_circle &&
    lhs.btn_cross == rhs.btn_cross &&
    lhs.AutonomMode == rhs.AutonomMode &&
    lhs.PID_DepthMode == rhs.PID_DepthMode &&
    lhs.PID_StabilizeMode == rhs.PID_StabilizeMode &&
    lhs.throttle == rhs.throttle &&
    lhs.Mission1_Mode == rhs.Mission1_Mode &&
    lhs.Mission2_Mode == rhs.Mission2_Mode &&
    lhs.Mission3_Status == rhs.Mission3_Status &&
    lhs.Mission4_Status == rhs.Mission4_Status;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::toggle_pkg::finalJoy_<ContainerAllocator1> & lhs, const ::toggle_pkg::finalJoy_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace toggle_pkg

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsMessage< ::toggle_pkg::finalJoy_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::toggle_pkg::finalJoy_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::toggle_pkg::finalJoy_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::toggle_pkg::finalJoy_<ContainerAllocator> const>
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::toggle_pkg::finalJoy_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::toggle_pkg::finalJoy_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::toggle_pkg::finalJoy_<ContainerAllocator> >
{
  static const char* value()
  {
    return "3d20946d4d46cc16c1a33df6866b61f3";
  }

  static const char* value(const ::toggle_pkg::finalJoy_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x3d20946d4d46cc16ULL;
  static const uint64_t static_value2 = 0xc1a33df6866b61f3ULL;
};

template<class ContainerAllocator>
struct DataType< ::toggle_pkg::finalJoy_<ContainerAllocator> >
{
  static const char* value()
  {
    return "toggle_pkg/finalJoy";
  }

  static const char* value(const ::toggle_pkg::finalJoy_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::toggle_pkg::finalJoy_<ContainerAllocator> >
{
  static const char* value()
  {
    return "string leftX\n"
"string leftY\n"
"string rightX\n"
"string rightY\n"
"string alter_right_x\n"
"string alter_right_y\n"
"string R1\n"
"string R2\n"
"string L1\n"
"string L2\n"
"string btn_triangle\n"
"string btn_square\n"
"string btn_circle\n"
"string btn_cross\n"
"string AutonomMode\n"
"string PID_DepthMode\n"
"string PID_StabilizeMode\n"
"string throttle\n"
"\n"
"# Circle\n"
"string Mission1_Mode \n"
"# Cross\n"
"string Mission2_Mode\n"
"# Start\n"
"string Mission3_Status\n"
"# Select\n"
"string Mission4_Status \n"
;
  }

  static const char* value(const ::toggle_pkg::finalJoy_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::toggle_pkg::finalJoy_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.leftX);
      stream.next(m.leftY);
      stream.next(m.rightX);
      stream.next(m.rightY);
      stream.next(m.alter_right_x);
      stream.next(m.alter_right_y);
      stream.next(m.R1);
      stream.next(m.R2);
      stream.next(m.L1);
      stream.next(m.L2);
      stream.next(m.btn_triangle);
      stream.next(m.btn_square);
      stream.next(m.btn_circle);
      stream.next(m.btn_cross);
      stream.next(m.AutonomMode);
      stream.next(m.PID_DepthMode);
      stream.next(m.PID_StabilizeMode);
      stream.next(m.throttle);
      stream.next(m.Mission1_Mode);
      stream.next(m.Mission2_Mode);
      stream.next(m.Mission3_Status);
      stream.next(m.Mission4_Status);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct finalJoy_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::toggle_pkg::finalJoy_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::toggle_pkg::finalJoy_<ContainerAllocator>& v)
  {
    s << indent << "leftX: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>>>::stream(s, indent + "  ", v.leftX);
    s << indent << "leftY: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>>>::stream(s, indent + "  ", v.leftY);
    s << indent << "rightX: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>>>::stream(s, indent + "  ", v.rightX);
    s << indent << "rightY: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>>>::stream(s, indent + "  ", v.rightY);
    s << indent << "alter_right_x: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>>>::stream(s, indent + "  ", v.alter_right_x);
    s << indent << "alter_right_y: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>>>::stream(s, indent + "  ", v.alter_right_y);
    s << indent << "R1: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>>>::stream(s, indent + "  ", v.R1);
    s << indent << "R2: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>>>::stream(s, indent + "  ", v.R2);
    s << indent << "L1: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>>>::stream(s, indent + "  ", v.L1);
    s << indent << "L2: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>>>::stream(s, indent + "  ", v.L2);
    s << indent << "btn_triangle: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>>>::stream(s, indent + "  ", v.btn_triangle);
    s << indent << "btn_square: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>>>::stream(s, indent + "  ", v.btn_square);
    s << indent << "btn_circle: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>>>::stream(s, indent + "  ", v.btn_circle);
    s << indent << "btn_cross: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>>>::stream(s, indent + "  ", v.btn_cross);
    s << indent << "AutonomMode: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>>>::stream(s, indent + "  ", v.AutonomMode);
    s << indent << "PID_DepthMode: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>>>::stream(s, indent + "  ", v.PID_DepthMode);
    s << indent << "PID_StabilizeMode: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>>>::stream(s, indent + "  ", v.PID_StabilizeMode);
    s << indent << "throttle: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>>>::stream(s, indent + "  ", v.throttle);
    s << indent << "Mission1_Mode: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>>>::stream(s, indent + "  ", v.Mission1_Mode);
    s << indent << "Mission2_Mode: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>>>::stream(s, indent + "  ", v.Mission2_Mode);
    s << indent << "Mission3_Status: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>>>::stream(s, indent + "  ", v.Mission3_Status);
    s << indent << "Mission4_Status: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>>>::stream(s, indent + "  ", v.Mission4_Status);
  }
};

} // namespace message_operations
} // namespace ros

#endif // TOGGLE_PKG_MESSAGE_FINALJOY_H
